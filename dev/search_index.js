var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [TensorBranching]","category":"page"},{"location":"api/#TensorBranching.AbstractBranching","page":"API","title":"TensorBranching.AbstractBranching","text":"abstract type AbstractBranching\n\nAbstract type representing a branching strategy. For each branching strategy, a corresponding impl_strategy function should be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.AbstractMeasure","page":"API","title":"TensorBranching.AbstractMeasure","text":"abstract type AbstractMeasure\n\nAbstract type representing a measurement of the size of given graphs. For each measurement, a corresponding measure function should be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.AbstractTruthFilter","page":"API","title":"TensorBranching.AbstractTruthFilter","text":"abstract type AbstractTruthFilter\n\nAbstract type representing a truth filter.\n\nThis type serves as a base for defining different truth filter strategies.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.AbstractVertexSelector","page":"API","title":"TensorBranching.AbstractVertexSelector","text":"abstract type AbstractVertexSelector\n\nAbstract type representing a vertex selector, which selects a subset of vertices from a given graph for branching. A corresponding select_vertex function should be implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.Branch","page":"API","title":"TensorBranching.Branch","text":"struct Branch\n\nA struct representing a branching strategy.\n\nFields\n\nvertices_removed::Vector{Int}: A vector of integers representing the vertices removed in the branching strategy.\nmis::Int: An integer representing the maximum independent set (MIS) size of the branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.Branches","page":"API","title":"TensorBranching.Branches","text":"struct Branches\n\nA struct representing a collection of branches.\n\nFields\n\nbranches::Vector{Branch}: A vector of Branch objects.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.BranchingNode","page":"API","title":"TensorBranching.BranchingNode","text":"mutable struct BranchingNode\n\nA mutable struct representing a node in a branching tree.\n\nFields\n\nchildren::Vector{BranchingNode}: The children nodes of the current node.\ngraph::SimpleGraph{Int}: The graph associated with the current node.\nremoved::Vector{Vector{Int}}: The removed edges from the graph.\n\nConstructor\n\nBranchingNode(graph::SimpleGraph{Int}; children::Vector{BranchingNode} = Vector{BranchingNode}(), removed::Vector{Vector{Int}} = Vector{Vector{Int}}()): Constructs a new BranchingNode object.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.BranchingTable","page":"API","title":"TensorBranching.BranchingTable","text":"BranchingTable{INT}\n\nA table of branching configurations. The table is a vector of vectors of INT. Type parameters are:\n\nINT: The number of integers as the storage.\n\nFields\n\nbit_length::Int: The length of the bit string.\ntable::Vector{Vector{INT}}: The table of bitstrings used for branching.\n\nTo cover the branching table, at least one clause in each row must be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.Clause","page":"API","title":"TensorBranching.Clause","text":"Clause{INT <: Integer}\n\nA clause is a pair of bit strings, mask and val, where mask is a bit string that indicates the bits that are relevant to the clause, and val is a bit string that indicates the bits that must be satisfied. The clause is satisfied if and only if val is covered by the bit string and mask.\n\nINT: The number of integers as the storage.\n\nExamples\n\njulia> Clause(bit\"1110\", bit\"1001\")\nClause{DitStr{2, 4, Int64}}: mask: 1110 ₍₂₎, val: 1000 ₍₂₎\n\nIf some bit in mask is set as 0, then the corresponding bit in val must be 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.CountingMIS","page":"API","title":"TensorBranching.CountingMIS","text":"struct CountingMIS\n\nA struct representing a counting maximum independent set (MIS), where mis for size of the maximum independent set and count for the count of branches.\n\nFields\n\nmis::Int: The maximum independent set.\ncount::Int: The count of the maximum independent set.\n\nConstructors\n\nCountingMIS(mis::Int): Constructs a CountingMIS object with the given maximum independent set and count set to 1.\nCountingMIS(mis::Int, count::Int): Constructs a CountingMIS object with the given maximum independent set and count.\n\nExamples\n\njulia> CountingMIS(2, 2) + 2\nCountingMIS(4, 2)\n\njulia> CountingMIS(1, 1) + CountingMIS(2, 2)\nCountingMIS(3, 3)\n\njulia> max(CountingMIS(1, 1), CountingMIS(2, 2))\nCountingMIS(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.D3Measure","page":"API","title":"TensorBranching.D3Measure","text":"D3Measure <: AbstractMeasure\n\nA measure of complexity by counting the number of vertices with degree at least 3.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.EnvFilter","page":"API","title":"TensorBranching.EnvFilter","text":"struct EnvFilter <: AbstractTruthFilter\n\nA struct representing an environment filter, using the information of the environment to filter out some configurations which can not reach the optimal mis solution.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.MinBoundarySelector","page":"API","title":"TensorBranching.MinBoundarySelector","text":"struct MinBoundarySelector <: AbstractVertexSelector\n\nThe MinBoundarySelector struct represents a strategy for selecting a subgraph with the minimum number of open vertices by k-layers of neighbors.\n\nFields\n\nk::Int: The number of layers of neighbors to consider when selecting the subgraph.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.NaiveBranching","page":"API","title":"TensorBranching.NaiveBranching","text":"struct NaiveBranching <: AbstractBranching\n\nA struct representing the NaiveBranching branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SetCoverBranching","page":"API","title":"TensorBranching.SetCoverBranching","text":"struct SetCoverBranching <: AbstractBranching\n\nA struct representing a branching strategy for set cover problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations.\n\nConstructors\n\nSetCoverBranching(): Constructs a SetCoverBranching object with a default value of 2 for max_itr.\nSetCoverBranching(max_itr::Int): Constructs a SetCoverBranching object with the specified max_itr value.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SolverConfig","page":"API","title":"TensorBranching.SolverConfig","text":"SolverConfig{ST<:AbstractMISSolver, BT<:AbstractBranching, MT<:AbstractMeasure, VT<:AbstractVertexSelector, FT<:AbstractTruthFilter}\n\nThe configuration for the optimal branching MIS solver.\n\nFields\n\ntable_solver::ST: the MIS solver, e.g., TensorNetworkSolver()\nbranching_strategy::BT: the branching strategy, e.g., NaiveBranching(), SetCoverBranching()\nmeasure::MT: the measure for the branching strategy, e.g., NumOfVertices(), D3Measure()\nvertex_selector::VT: the vertex selector, e.g., MinBoundarySelector(2), ManualSelector([1, 2, 3])\ntable_filter::FT: the truth filter, e.g., EnvFilter(), NoFilter()\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SubCover","page":"API","title":"TensorBranching.SubCover","text":"SubCover{INT <: Integer}\n\nA subcover is a pair of a set of integers ids, a clause clause and a integer n_rm. The ids for the truth covered by the clause, and n_rm is the number of vertices to remove.\n\nINT: The number of integers as the storage.\n\nExamples\n\njulia> SubCover([1, 2], Clause(bit\"1110\", bit\"1001\"), 3)\nSubCover{DitStr{2, 4, Int64}}: ids: Set([2, 1]), mask: 1110 ₍₂₎, val: 1000 ₍₂₎, n_rm: 3\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.branching_tree-Tuple{SimpleGraph, SolverConfig}","page":"API","title":"TensorBranching.branching_tree","text":"branching_tree(g::SimpleGraph, config::SolverConfig)\n\nConstructs a branching tree based on the given graph g using the specified config.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.clause-Union{Tuple{INT}, Tuple{Int64, AbstractVector{INT}}} where INT","page":"API","title":"TensorBranching.clause","text":"clause(n::Int, bitstrings::AbstractVector{INT})\n\nReturn a clause that covers all the bit strings.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.closed_neighbors-Tuple{SimpleGraph, Vector{Int64}}","page":"API","title":"TensorBranching.closed_neighbors","text":"closed_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a set of vertices that includes the input vertices as well as their open neighbors.\n\nArguments\n\ng::SimpleGraph: The input graph.\nvertices::Vector{Int}: The vertices for which closed neighbors are to be computed.\n\nReturns\n\nA set of vertices that includes the input vertices as well as their open neighbors.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.complexity-Tuple{Vector{Int64}}","page":"API","title":"TensorBranching.complexity","text":"complexity(sbranches::Vector{Int})\n\nCompute the complexity of a set of branches.\n\nThis function solves the equation 1 = sum(x^(-i) for i in sbranches) for x, where sbranches is a vector of integers representing the branches.\n\nArguments\n\nsbranches::Vector{Int}: A vector of integers representing the branches.\n\nReturns\n\nFloat64: The value of x that satisfies the equation.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.count_mis-Tuple{SimpleGraph, SolverConfig}","page":"API","title":"TensorBranching.count_mis","text":"count_mis(g::SimpleGraph, config::SolverConfig)\n\nCount the number of MIS for the given graph and configuration.\n\nArguments\n\ng::SimpleGraph: the input graph\nconfig::SolverConfig: the solver configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.counting_mis1-Tuple{EliminateGraphs.EliminateGraph}","page":"API","title":"TensorBranching.counting_mis1","text":"counting_mis1(eg::EliminateGraph)\n\nCompute the size of the maximum independent set (MIS) in the given EliminateGraph and the number of branches by mis1.\n\nArguments\n\neg::EliminateGraph: The graph to compute the MIS for.\n\nReturns\n\nCountingMIS: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.counting_mis2-Tuple{EliminateGraphs.EliminateGraph}","page":"API","title":"TensorBranching.counting_mis2","text":"counting_mis2(eg::EliminateGraph)\n\nCompute the size of the maximum independent set (MIS) in the given EliminateGraph and the number of branches by mis2.\n\nArguments\n\neg::EliminateGraph: The graph to compute the MIS for.\n\nReturns\n\nCountingMIS: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.cover-Union{Tuple{TF}, Tuple{INT}, Tuple{AbstractArray{SubCover{INT}, 1}, Int64}} where {INT, TF}","page":"API","title":"TensorBranching.cover","text":"cover(sub_covers::AbstractVector{SubCover{INT}}; max_itr::Int = 2, min_complexity::TF = 1.0) where{N, T, TF}\n\nThe cover function performs a set covering algorithm on a collection of sub-covers.\n\nArguments\n\nsub_covers::AbstractVector{SubCover{INT}}: A collection of sub-covers.\nmax_itr::Int = 2: The maximum number of iterations to perform.\nmin_complexity::TF = 1.0: The minimum complexity threshold.\n\nReturns\n\npicked: The selected sub-covers.\ncx: The complexity of the selected sub-covers.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_by-Tuple{Any, Any, Any}","page":"API","title":"TensorBranching.covered_by","text":"covered_by(a::LongLongUInt, b::LongLongUInt, mask::LongLongUInt)\n\nCheck if a is covered by b with mask. The function returns true if and only if a and b are the same when masked by mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_by-Tuple{Any, Clause}","page":"API","title":"TensorBranching.covered_by","text":"covered_by(a::LongLongUInt, clause::Clause)\n\nCheck if a is covered by the clause. The function returns true if and only if a and clause.val are the same when masked by clause.mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_items-Tuple{Any, Clause}","page":"API","title":"TensorBranching.covered_items","text":"covered_items(bitstrings, clause::Clause)\n\nReturn the indices of the bit strings that are covered by the clause.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.effective_γ-Tuple{Branches, SimpleGraph, AbstractMeasure}","page":"API","title":"TensorBranching.effective_γ","text":"effective_γ(branches::Branches, g::SimpleGraph, measure::AbstractMeasure)\n\nCompute the effective γ value for a set of branches in a graph under a given measure.\n\nThis function calculates the effective γ value for a given set of branches in a graph. The effective γ value is a measure of complexity that takes into account the size reduction achieved by removing vertices from the graph.\n\nArguments\n\nbranches::Branches: The set of branches for which to calculate the effective γ value.\ng::SimpleGraph: The graph for which to calculate the effective γ value.\nmeasure::AbstractMeasure: The measure used to calculate the size reduction.\n\nReturns\n\nThe effective γ value for the set of branches.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.graph_from_artifact-Tuple{Int64}","page":"API","title":"TensorBranching.graph_from_artifact","text":"graph_from_artifact(num::Int)\n\nLoad a graph of the PACE2019 dataset as SimpleGraph.\n\nArguments\n\nnum::Int: The number of the artifact.\n\nExamples\n\njulia> graph_from_artifact(1)\n{6160, 40207} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.mis_solver-Tuple{SimpleGraph, SolverConfig}","page":"API","title":"TensorBranching.mis_solver","text":"mis_solver(g::SimpleGraph, config::SolverConfig)\n\nSolves the maximum independent set (MIS) problem for a given graph g using a recursive algorithm.\n\nArguments\n\ng::SimpleGraph: The input graph.\nconfig::SolverConfig: Configuration options for the solver, see SolverConfig.\n\nReturns\n\nmax_mis: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.neighbor_cover-Tuple{SimpleGraph, Int64, Int64}","page":"API","title":"TensorBranching.neighbor_cover","text":"neighbor_cover(g::SimpleGraph, v::Int, k::Int)\n\nCompute the neighbor cover of a vertex in a graph.\n\nArguments\n\ng::SimpleGraph: The input graph.\nv::Int: The vertex for which to compute the neighbor cover.\nk::Int: The number of iterations to perform.\n\nReturns\n\nvertices: An array containing the vertices in the neighbor cover.\nopenvertices: An array containing the open vertices in the neighbor cover.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.neighbors_2nd-Tuple{SimpleGraph, Int64}","page":"API","title":"TensorBranching.neighbors_2nd","text":"neighbors_2nd(g::SimpleGraph, v::Int)\n\nReturn the second-order neighbors of a vertex v in a simple graph g.\n\nArguments\n\ng::SimpleGraph: The simple graph.\nv::Int: The vertex.\n\nReturns\n\nArray{Int}: An array of second-order neighbors of v.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.open_neighbors-Tuple{SimpleGraph, Vector{Int64}}","page":"API","title":"TensorBranching.open_neighbors","text":"open_neighbors(g::SimpleGraph, vertices::Vector{Int})\n\nReturns a vector of vertices in the graph g, which are neighbors of the given vertices and not in the given vertices.\n\nArguments\n\ng::SimpleGraph: The graph in which to find the open neighbors.\nvertices::Vector{Int}: The vertices for which to find the open neighbors.\n\nReturns\n\nA vector of open neighbors of the given vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.open_vertices-Tuple{SimpleGraph, Vector{Int64}}","page":"API","title":"TensorBranching.open_vertices","text":"open_vertices(g::SimpleGraph, vertices::Vector{Int})\n\nRemove vertices from the given vector that are connected to all other vertices in the graph.\n\nArguments\n\ng::SimpleGraph: The graph object.\nvertices::Vector{Int}: The vector of vertices.\n\nReturns\n\nVector{Int}: The open vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.optimal_branches-Tuple{SimpleGraph, AbstractVector, AbstractBranching}","page":"API","title":"TensorBranching.optimal_branches","text":"optimal_branches(g::SimpleGraph, vertices::AbstractVector, strategy::AbstractBranching; measure::AbstractMeasure = NumOfVertices(), filter::AbstractTruthFilter = NoFilter())\n\nFind the optimal branches for the given graph and vertices.\n\nArguments\n\ng::SimpleGraph: the input graph\nvertices::AbstractVector: the vertices to be considered\nstrategy::AbstractBranching: the branching strategy, e.g., NaiveBranching(), SetCoverBranching()\n\nKeyword Arguments\n\nmeasure::AbstractMeasure: the measure for the branching strategy, e.g., NumOfVertices(), D3Measure()\nfilter::AbstractTruthFilter: the filter for the branching strategy, e.g., EnvFilter(), NoFilter()\ntable_solver: the solver configuration, e.g., TensorNetworkSolver()\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.removed_vertices-Union{Tuple{N}, Tuple{Vector{Int64}, SimpleGraph, Clause{N}}} where N","page":"API","title":"TensorBranching.removed_vertices","text":"removed_vertices(vertices::Vector{Int}, g::SimpleGraph, clause::Clause{N}) where N\n\nGiven a list of vertices, a graph, and a clause, this function returns a list of removed vertices. \n\nThe vertices argument is a vector of integers representing the vertices to consider.  The g argument is a SimpleGraph object representing the graph. The clause argument is a Clause object representing a clause.\n\nThe function iterates over the vertices and checks if the corresponding bit in the clause.mask is 1.  If it is, the vertex is added to the list of removed vertices (rvs).  If the corresponding bit in the clause.val is also 1, the neighbors of the vertex are also added to rvs.\n\nThe function returns the list of removed vertices with duplicates removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.setcover_strategy-Union{Tuple{INT}, Tuple{BranchingTable{INT}, Vector{Int64}, SimpleGraph, Int64, AbstractMeasure}} where INT","page":"API","title":"TensorBranching.setcover_strategy","text":"setcover_strategy(tbl::BranchingTable{INT}, vertices::Vector{Int}, g::SimpleGraph, max_itr::Int, measure::AbstractMeasure) where{INT}\n\nThis function implements a set covering strategy for the optimal branching in the following steps.\n\nCompute the sub-covers of the branching table.\nA set of sub-covers with minimum effective γ is selected by the set covering algorithm.\nThe selected sub-covers are converted to branching rules.\n\nArguments\n\ntbl::BranchingTable{INT}: The branching table.\nvertices::Vector{Int}: The vertices to be covered.\ng::SimpleGraph: The graph.\nmax_itr::Int: The maximum number of iterations.\nmeasure::AbstractMeasure: The measure used to evaluate the quality of a cover.\n\nReturns\n\nbranches: The branches generated by the set covering strategy.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.solve_mis-Tuple{SimpleGraph, SolverConfig}","page":"API","title":"TensorBranching.solve_mis","text":"solve_mis(g::SimpleGraph, config::SolverConfig)\n\nSolve the maximum independent set problem for the given graph and configuration.\n\nArguments\n\ng::SimpleGraph: the input graph\nconfig::SolverConfig: the solver configuration\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.subcovers-Union{Tuple{INT}, Tuple{AbstractArray{Vector{INT}, 1}, Vector{Int64}, SimpleGraph, AbstractMeasure}} where INT","page":"API","title":"TensorBranching.subcovers","text":"subcovers(bss::AbstractVector{Vector{INT}}, vertices::Vector{Int}, g::SimpleGraph, use_rv::Bool) where {INT}\n\nCompute the subcovers of a set of bit strings by iteratively gathering clauses.\n\nArguments\n\nbss::AbstractVector{Vector{INT}}: A vector of vectors of bit strings.\nvertices::Vector{Int}: A vector of integers representing vertices.\ng::SimpleGraph: A simple graph.\nuse_rv::Bool: A boolean indicating whether to use the number of vertices removed.\n\nReturns\n\nallcovers::Vector{SubCover}: A vector of SubCover objects representing the subcovers.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.subcovers_naive-Union{Tuple{INT}, Tuple{Int64, Union{AbstractArray{Vector{INT}, 1}, Vector{INT}}, Vector{Int64}, SimpleGraph, AbstractMeasure}} where INT","page":"API","title":"TensorBranching.subcovers_naive","text":"subcovers_naive(bs, vertices, g, use_rv)\n\nCompute the subcovers for a given set of bit strings by search all possible clauses.\n\nArguments\n\nbs::Union{Vector{INT}, AbstractVector{Vector{INT}}}: The set of bit strings.\nvertices::Vector{Int}: The vertices.\ng::SimpleGraph: The graph.\nuse_rv::Bool: A flag indicating whether to use the number of vertices removed.\n\nReturns\n\nallcovers::Vector{SubCover{INT}}: The computed subcovers.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorBranching","category":"page"},{"location":"#TensorBranching.jl","page":"Home","title":"TensorBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensorBranching.jl.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] to enter the package mode in Julia Repl, and type the following command to install the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/ArrogantGao/TensorBranching.jl","category":"page"},{"location":"#solve-the-maximum-independent-set-problem","page":"Home","title":"solve the maximum independent set problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently we provide a simple interface to solve the maximum independent set problem. You can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TensorBranching\n\njulia> branching_strategy = SetCoverBranching()\nSetCoverBranching(3)\n\njulia> vertex_selector = MinBoundarySelector(2)\nMinBoundarySelector(2)\n\njulia> measure = D3Measure()\nD3Measure()\n\njulia> table_filter = EnvFilter()\nEnvFilter()\n\njulia> cfg = SolverConfig(; branching_strategy, vertex_selector, measure, table_filter)\nSolverConfig{TensorNetworkSolver, SetCoverBranching, D3Measure, MinBoundarySelector, EnvFilter}(TensorNetworkSolver(), SetCoverBranching(3), D3Measure(), MinBoundarySelector(2), EnvFilter())\n\njulia> g = smallgraph(:tutte)\n{46, 69} undirected simple Int64 graph\n\njulia> solve_mis(g, cfg)\n19\n\njulia> count_mis(g, cfg)\n(19, 5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard mis1 and mis2 strategies are also available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TensorBranching\n\njulia> counting_mis2(g)\nCountingMIS(19, 139)\n\njulia> counting_mis1(g)\nCountingMIS(19, 1697552)","category":"page"},{"location":"#Branching-Tree","page":"Home","title":"Branching Tree","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To check the branching process in detail, we store all the branching process as tree.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> tree, c = branching_tree(g, cfg)\n(G{46}\n├─ G{41}\n│  └─ G{39}\n│     └─ G{37}\n│        └─ G{35}\n│           └─ G{32}\n│              ⋮\n│              \n└─ G{42}\n   └─ G{41}\n      └─ G{39}\n         └─ G{37}\n            └─ G{35}\n               ⋮\n               \n, 4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the graph of current state, the vertices to be removed are stored:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> tree.graph\n{46, 69} undirected simple Int64 graph\n\njulia> tree.removed\n3-element Vector{Vector{Int64}}:\n [2, 1, 5, 27]\n [2, 1, 3, 4, 5, 6, 34, 27, 26]\n [2, 1, 5, 6, 34, 27, 26, 3, 11, 12, 4, 19, 20]","category":"page"},{"location":"","page":"Home","title":"Home","text":"the vertices to be removed correspond to the children of the current node.","category":"page"}]
}
