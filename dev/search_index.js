var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [TensorBranching]","category":"page"},{"location":"api/#TensorBranching.BranchingNode","page":"API","title":"TensorBranching.BranchingNode","text":"mutable struct BranchingNode\n\nA mutable struct representing a node in a branching tree.\n\nFields\n\nchildren::Vector{BranchingNode}: The children nodes of the current node.\ngraph::SimpleGraph{Int}: The graph associated with the current node.\nremoved::Vector{Vector{Int}}: The removed edges from the graph.\n\nConstructor\n\nBranchingNode(graph::SimpleGraph{Int}; children::Vector{BranchingNode} = Vector{BranchingNode}(), removed::Vector{Vector{Int}} = Vector{Vector{Int}}()): Constructs a new BranchingNode object.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.BranchingTable","page":"API","title":"TensorBranching.BranchingTable","text":"BranchingTable{N, C}\n\nA table of branching configurations. The table is a vector of vectors of StaticBitVector{N, C}. Type parameters are:\n\nN: The number of bits in the bit vector.\nC: The number of integers as the storage.\n\nExamples\n\njulia> graph_sat = graph_from_tuples(3, [(1, 2), (2, 3), (1, 3)])\n{3, 3} undirected simple Int64 graph\n\njulia> tbl = reduced_alpha_configs(graph_sat, [1, 2])\nBranchingTable{N}\n001\n\nTo cover the branching table, at least one clause in each row must be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.Clause","page":"API","title":"TensorBranching.Clause","text":"Clause{N, T}\n\nA clause is a pair of bit strings, mask and val, where mask is a bit string that indicates the bits that are relevant to the clause, and val is a bit string that indicates the bits that must be satisfied. The clause is satisfied if and only if val is covered by the bit string and mask.\n\nN: The number of bits in the bit vector.\nT: The number of integers as the storage.\n\nExamples\n\njulia> Clause(bit\"1110\", bit\"1001\")\nClause{4, 3, Int64}: mask: 1110 ₍₂₎, val: 1000 ₍₂₎\n\nIf some bit in mask is set as 0, then the corresponding bit in val must be 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.NaiveBranching","page":"API","title":"TensorBranching.NaiveBranching","text":"struct NaiveBranching <: BranchingStrategy\n\nA struct representing the NaiveBranching branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SetCoverBranching","page":"API","title":"TensorBranching.SetCoverBranching","text":"struct SetCoverBranching <: BranchingStrategy\n\nA struct representing a branching strategy for set cover problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations.\n\nConstructors\n\nSetCoverBranching(): Constructs a SetCoverBranching object with a default value of 2 for max_itr.\nSetCoverBranching(max_itr::Int): Constructs a SetCoverBranching object with the specified max_itr value.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SubCover","page":"API","title":"TensorBranching.SubCover","text":"SubCover{N, T}\n\nA subcover is a pair of a set of integers ids, a clause clause and a integer n_rm. The ids for the truth covered by the clause, and n_rm is the number of vertices to remove.\n\nN: The number of bits in the bit vector.\nT: The number of integers as the storage.\n\nExamples\n\njulia> SubCover([1, 2], Clause(bit\"1110\", bit\"1001\"), 3)\nSubCover{4, Int64}: ids: Set([2, 1]), mask: 1110 ₍₂₎, val: 1000 ₍₂₎, n_rm: 3\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.branching_tree-Tuple{SimpleGraph, BranchingStrategy, Int64, Bool}","page":"API","title":"TensorBranching.branching_tree","text":"branching_tree(g::SimpleGraph, strategy::BranchingStrategy, kneighbor::Int, use_rv::Bool)\n\nConstructs a branching tree based on the given graph g using the specified strategy. The kneighbor parameter determines the number of neighbors to consider during branching. If use_rv is true, number of vertex removed is used; otherwise, only count the clause.\n\nArguments\n\ng::SimpleGraph: The input graph.\nstrategy::BranchingStrategy: The branching strategy to use.\nkneighbor::Int: The number of neighbors to consider during branching.\nuse_rv::Bool: Whether to use number of vertex removed.\n\nReturns\n\ntree: The constructed branching tree.\nbranch_num: The number of branches in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.clause-Union{Tuple{AbstractArray{BitStr{N, T}, 1}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API","title":"TensorBranching.clause","text":"clause(bitstrings::AbstractVector{BitStr{N, T}})\n\nReturn a clause that covers all the bit strings.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.complexity-Tuple{Vector{Int64}}","page":"API","title":"TensorBranching.complexity","text":"complexity(sbranches::Vector{Int})\n\nCompute the complexity of a set of branches.\n\nThis function solves the equation 1 = sum(x^(-i) for i in sbranches) for x, where sbranches is a vector of integers representing the branches.\n\nArguments\n\nsbranches::Vector{Int}: A vector of integers representing the branches.\n\nReturns\n\nFloat64: The value of x that satisfies the equation.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.counting_mis1-Tuple{EliminateGraphs.EliminateGraph}","page":"API","title":"TensorBranching.counting_mis1","text":"counting_mis1(eg::EliminateGraph)\n\nCompute the size of the maximum independent set (MIS) in the given EliminateGraph and the number of branches by mis1.\n\nArguments\n\neg::EliminateGraph: The graph to compute the MIS for.\n\nReturns\n\nCountingMIS: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.counting_mis2-Tuple{EliminateGraphs.EliminateGraph}","page":"API","title":"TensorBranching.counting_mis2","text":"counting_mis2(eg::EliminateGraph)\n\nCompute the size of the maximum independent set (MIS) in the given EliminateGraph and the number of branches by mis2.\n\nArguments\n\neg::EliminateGraph: The graph to compute the MIS for.\n\nReturns\n\nCountingMIS: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.cover-Union{Tuple{AbstractArray{SubCover{N, T}, 1}}, Tuple{TF}, Tuple{T}, Tuple{N}} where {N, T, TF}","page":"API","title":"TensorBranching.cover","text":"cover(sub_covers::AbstractVector{SubCover{N, T}}; max_itr::Int = 2, min_complexity::TF = 1.0) where{N, T, TF}\n\nThe cover function performs a set covering algorithm on a collection of sub-covers.\n\nArguments\n\nsub_covers::AbstractVector{SubCover{N, T}}: A collection of sub-covers.\nmax_itr::Int = 2: The maximum number of iterations to perform.\nmin_complexity::TF = 1.0: The minimum complexity threshold.\n\nReturns\n\npicked: The selected sub-covers.\ncx: The complexity of the selected sub-covers.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_by-Tuple{Any, Any, Any}","page":"API","title":"TensorBranching.covered_by","text":"covered_by(a::BitStr, b::BitStr, mask::BitStr)\n\nCheck if a is covered by b with mask. The function returns true if and only if a and b are the same when masked by mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_by-Tuple{Any, Clause}","page":"API","title":"TensorBranching.covered_by","text":"covered_by(a::BitStr, clause::Clause)\n\nCheck if a is covered by the clause. The function returns true if and only if a and clause.val are the same when masked by clause.mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_items-Tuple{Any, Clause}","page":"API","title":"TensorBranching.covered_items","text":"covered_items(bitstrings, clause::Clause)\n\nReturn the indices of the bit strings that are covered by the clause.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.env_filter-Union{Tuple{C}, Tuple{N}, Tuple{BranchingTable{N, C}, SimpleGraph, Vector{Int64}, Vector{Int64}}} where {N, C}","page":"API","title":"TensorBranching.env_filter","text":"env_filter(tbl::BranchingTable{N, C}, g::SimpleGraph, vertices::Vector{Int}, openvertices::Vector{Int}) -> BranchingTable\n\nFilter the given tbl based on the environment of the vertices.\n\nArguments\n\ntbl::BranchingTable{N, C}: The branching table to filter.\ng::SimpleGraph: The graph representing the environment.\nvertices::Vector{Int}: The vertices to consider.\nopenvertices::Vector{Int}: The open vertices.\n\nReturns\n\nA new BranchingTable object containing the filtered rows.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.missolve-Tuple{SimpleGraph}","page":"API","title":"TensorBranching.missolve","text":"missolve(g::SimpleGraph; show_count = false, strategy::BranchingStrategy = NaiveBranching(), kneighbor::Int = 2, use_rv::Bool = true)\n\nSolves the maximum independent set (MIS) problem for a given graph g using a specified branching strategy.\n\nArguments\n\ng::SimpleGraph: The input graph.\nshow_count::Bool = false: Whether to return the count of iterations performed during the solving process.\nstrategy::BranchingStrategy = NaiveBranching(): The branching strategy to use. Defaults to NaiveBranching().\nkneighbor::Int = 2: The number of neighbors to consider during the branching process. Defaults to 2.\nuse_rv::Bool = true: Whether to use number of removed vertices during the branching process. Defaults to true.\n\nReturns\n\nIf show_count is false, returns the maximum independent set (MIS) of the graph g.\nIf show_count is true, returns a tuple (mis, count) where mis is the maximum independent set (MIS) of the graph g and count is the number of iterations performed during the solving process.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.optimal_branching_dnf-Tuple{SimpleGraph, BranchingStrategy, Int64, Bool}","page":"API","title":"TensorBranching.optimal_branching_dnf","text":"optimal_branching_dnf(g::SimpleGraph, strategy::BranchingStrategy, kneighbor::Int, use_rv::Bool)\n\nCompute the optimal branching in a directed acyclic graph (DAG) using a specified branching strategy.\n\nArguments\n\ng::SimpleGraph: The input graph.\nstrategy::BranchingStrategy: The branching strategy to use.\nkneighbor::Int: The number of neighbors to consider when selecting the branching vertex.\nuse_rv::Bool: Whether to use the number of removed vertices during the branching process.\n\nReturns\n\nvertices: The set of vertices selected for the optimal branching.\nopenvertices: The set of open vertices in the optimal branching.\nimpl_strategy: The implementation strategy used for the optimal branching.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.setcover_strategy-Union{Tuple{C}, Tuple{N}, Tuple{BranchingTable{N, C}, Vector{Int64}, SimpleGraph, Bool}} where {N, C}","page":"API","title":"TensorBranching.setcover_strategy","text":"setcover_strategy(tbl::BranchingTable{N, C}, vertices::Vector{Int}, g::SimpleGraph, use_rv::Bool; max_itr::Int = 1) where{N, C}\n\nThis function implements a set covering strategy for a given set of vertices in a graph.\n\nArguments\n\ntbl::BranchingTable{N, C}: The branching table.\nvertices::Vector{Int}: The set of vertices to cover.\ng::SimpleGraph: The graph.\nuse_rv::Bool: A flag indicating whether to use the number of vertices removed.\nmax_itr::Int = 2: The maximum number of iterations.\n\nReturns\n\nDNF: The branching strategy.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.subcovers-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{Array{BitStr{N, T}, 1}, 1}, Vector{Int64}, SimpleGraph, Bool}} where {N, T}","page":"API","title":"TensorBranching.subcovers","text":"subcovers(bss::AbstractVector{Vector{BitStr{N, T}}}, vertices::Vector{Int}, g::SimpleGraph, use_rv::Bool) where {N, T}\n\nCompute the subcovers of a set of bit strings by iteratively gathering clauses.\n\nArguments\n\nbss::AbstractVector{Vector{BitStr{N, T}}}: A vector of vectors of bit strings.\nvertices::Vector{Int}: A vector of integers representing vertices.\ng::SimpleGraph: A simple graph.\nuse_rv::Bool: A boolean indicating whether to use the number of vertices removed.\n\nReturns\n\nallcovers::Vector{SubCover}: A vector of SubCover objects representing the subcovers.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.subcovers_naive-Union{Tuple{T}, Tuple{N}, Tuple{Union{AbstractArray{Array{BitStr{N, T}, 1}, 1}, Array{BitStr{N, T}, 1}}, Vector{Int64}, SimpleGraph, Bool}} where {N, T}","page":"API","title":"TensorBranching.subcovers_naive","text":"subcovers_naive(bs, vertices, g, use_rv)\n\nCompute the subcovers for a given set of bit strings by search all possible clauses.\n\nArguments\n\nbs::Union{Vector{BitStr{N, T}}, AbstractVector{Vector{BitStr{N, T}}}}: The set of bit strings.\nvertices::Vector{Int}: The vertices.\ng::SimpleGraph: The graph.\nuse_rv::Bool: A flag indicating whether to use the number of vertices removed.\n\nReturns\n\nallcovers::Vector{SubCover{N, T}}: The computed subcovers.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorBranching","category":"page"},{"location":"#TensorBranching.jl","page":"Home","title":"TensorBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensorBranching.jl.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] to enter the package mode in Julia Repl, and type the following command to install the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/ArrogantGao/TensorBranching.jl","category":"page"},{"location":"#solve-the-maximum-independent-set-problem","page":"Home","title":"solve the maximum independent set problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently we provide a simple interface to solve the maximum independent set problem. You can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> g = random_regular_graph(60, 3)\n{60, 90} undirected simple Int64 graph\n\njulia> missolve(g, strategy = SetCoverBranching(), kneighbor = 1, show_count = true, usr_rv = true)\n(26, 206)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where kneighbor for layer of neighbor considered, the first result is the size of the maximum independent set, and the second result is the number of branches visited.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard mis1 and mis2 strategies are also available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TensorBranching: counting_mis1, counting_mis2\n\njulia> using EliminateGraphs\n\njulia> counting_mis1(EliminateGraph(g))\nCountingMIS(26, 58148786)\n\njulia> counting_mis2(EliminateGraph(g))\nCountingMIS(26, 188)","category":"page"},{"location":"#Branching-Tree","page":"Home","title":"Branching Tree","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To check the branching process in detail, we store all the branching process as tree.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> g = random_regular_graph(20, 3)\n{20, 30} undirected simple Int64 graph\n\njulia> tree, mis = branching_tree(g, SetCoverBranching(), 1, use_rv = true)\n(G{20}\n├─ G{16}\n│  └─ G{14}\n│     ├─ G{11}\n│     │  └─ G{9}\n│     │     └─ G{7}\n│     │        ⋮\n│     │        \n│     └─ G{7}\n│        └─ G{5}\n│           └─ G{3}\n│              ⋮\n│              \n├─ G{12}\n│  └─ G{10}\n│     └─ G{8}\n│        ├─ G{5}\n│        │  └─ G{3}\n│        │     ⋮\n│        │     \n│        └─ G{3}\n│           └─ G{0}\n└─ G{16}\n   └─ G{14}\n      ├─ G{11}\n      │  └─ G{9}\n      │     └─ G{7}\n      │        ⋮\n      │        \n      └─ G{8}\n         └─ G{6}\n            └─ G{4}\n               ⋮\n               \n, 6)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the graph of current state, the vertices to be removed are stored:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> tree.graph\n{20, 30} undirected simple Int64 graph\n\njulia> tree.removed\n3-element Vector{Vector{Int64}}:\n [1, 5, 13, 20]\n [1, 5, 13, 10, 15, 20, 4, 16]\n [1, 5, 12, 16]","category":"page"},{"location":"","page":"Home","title":"Home","text":"the vertices to be removed correspond to the children of the current node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
