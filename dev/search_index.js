var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [TensorBranching]","category":"page"},{"location":"api/#TensorBranching.BranchingNode","page":"API","title":"TensorBranching.BranchingNode","text":"mutable struct BranchingNode\n\nA mutable struct representing a node in a branching tree.\n\nFields\n\nchildren::Vector{BranchingNode}: The children nodes of the current node.\ngraph::SimpleGraph{Int}: The graph associated with the current node.\nremoved::Vector{Vector{Int}}: The removed edges from the graph.\n\nConstructor\n\nBranchingNode(graph::SimpleGraph{Int}; children::Vector{BranchingNode} = Vector{BranchingNode}(), removed::Vector{Vector{Int}} = Vector{Vector{Int}}()): Constructs a new BranchingNode object.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.BranchingTable","page":"API","title":"TensorBranching.BranchingTable","text":"BranchingTable{N, C}\n\nA table of branching configurations. The table is a vector of vectors of StaticBitVector{N, C}. Type parameters are:\n\nN: The number of bits in the bit vector.\nC: The number of integers as the storage.\n\nExamples\n\njulia> graph_sat = graph_from_tuples(3, [(1, 2), (2, 3), (1, 3)])\n{3, 3} undirected simple Int64 graph\n\njulia> tbl = reduced_alpha_configs(TensorNetworkSolver(), graph_sat, [1, 2])\nBranchingTable{N}\n001\n\nTo cover the branching table, at least one clause in each row must be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.Clause","page":"API","title":"TensorBranching.Clause","text":"Clause{N, T}\n\nA clause is a pair of bit strings, mask and val, where mask is a bit string that indicates the bits that are relevant to the clause, and val is a bit string that indicates the bits that must be satisfied. The clause is satisfied if and only if val is covered by the bit string and mask.\n\nN: The number of bits in the bit vector.\nT: The number of integers as the storage.\n\nExamples\n\njulia> Clause(bit\"1110\", bit\"1001\")\nClause{4, 3, Int64}: mask: 1110 ₍₂₎, val: 1000 ₍₂₎\n\nIf some bit in mask is set as 0, then the corresponding bit in val must be 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.D3Measure","page":"API","title":"TensorBranching.D3Measure","text":"D3Measure <: AbstractMeasure\n\nA measure of complexity by counting the number of vertices with degree at least 3.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.NaiveBranching","page":"API","title":"TensorBranching.NaiveBranching","text":"struct NaiveBranching <: AbstractBranching\n\nA struct representing the NaiveBranching branching strategy.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SetCoverBranching","page":"API","title":"TensorBranching.SetCoverBranching","text":"struct SetCoverBranching <: AbstractBranching\n\nA struct representing a branching strategy for set cover problems.\n\nFields\n\nmax_itr::Int: The maximum number of iterations.\n\nConstructors\n\nSetCoverBranching(): Constructs a SetCoverBranching object with a default value of 2 for max_itr.\nSetCoverBranching(max_itr::Int): Constructs a SetCoverBranching object with the specified max_itr value.\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SolverConfig","page":"API","title":"TensorBranching.SolverConfig","text":"SolverConfig{ST<:AbstractMISSolver, BT<:AbstractBranching, MT<:AbstractMeasure, VT<:AbstractVertexSelector, FT<:AbstractTruthFilter}\n\nThe configuration for the optimal branching MIS solver.\n\nFields\n\ntable_solver::ST: the MIS solver, e.g., TensorNetworkSolver()\nbranching_strategy::BT: the branching strategy, e.g., NaiveBranching(), SetCoverBranching()\nmeasurement::MT: the measurement for the branching strategy, e.g., NumOfVertices(), D3Measure()\nvertex_selector::VT: the vertex selector, e.g., MinBoundarySelector(2), ManualSelector([1, 2, 3])\ntable_filter::FT: the truth filter, e.g., EnvFilter(), NoFilter()\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.SubCover","page":"API","title":"TensorBranching.SubCover","text":"SubCover{N, T}\n\nA subcover is a pair of a set of integers ids, a clause clause and a integer n_rm. The ids for the truth covered by the clause, and n_rm is the number of vertices to remove.\n\nN: The number of bits in the bit vector.\nT: The number of integers as the storage.\n\nExamples\n\njulia> SubCover([1, 2], Clause(bit\"1110\", bit\"1001\"), 3)\nSubCover{4, Int64}: ids: Set([2, 1]), mask: 1110 ₍₂₎, val: 1000 ₍₂₎, n_rm: 3\n\n\n\n\n\n","category":"type"},{"location":"api/#TensorBranching.branching_tree-Tuple{SimpleGraph, AbstractBranching, Int64, Bool}","page":"API","title":"TensorBranching.branching_tree","text":"branching_tree(g::SimpleGraph, strategy::AbstractBranching, kneighbor::Int, use_rv::Bool)\n\nConstructs a branching tree based on the given graph g using the specified strategy. The kneighbor parameter determines the number of neighbors to consider during branching. If use_rv is true, number of vertex removed is used; otherwise, only count the clause.\n\nArguments\n\ng::SimpleGraph: The input graph.\nstrategy::AbstractBranching: The branching strategy to use.\nkneighbor::Int: The number of neighbors to consider during branching.\nuse_rv::Bool: Whether to use number of vertex removed.\n\nReturns\n\ntree: The constructed branching tree.\nbranch_num: The number of branches in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.clause-Union{Tuple{AbstractArray{BitStr{N, T}, 1}}, Tuple{T}, Tuple{N}} where {N, T}","page":"API","title":"TensorBranching.clause","text":"clause(bitstrings::AbstractVector{BitStr{N, T}})\n\nReturn a clause that covers all the bit strings.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.complexity-Tuple{Vector{Int64}}","page":"API","title":"TensorBranching.complexity","text":"complexity(sbranches::Vector{Int})\n\nCompute the complexity of a set of branches.\n\nThis function solves the equation 1 = sum(x^(-i) for i in sbranches) for x, where sbranches is a vector of integers representing the branches.\n\nArguments\n\nsbranches::Vector{Int}: A vector of integers representing the branches.\n\nReturns\n\nFloat64: The value of x that satisfies the equation.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.counting_mis1-Tuple{EliminateGraphs.EliminateGraph}","page":"API","title":"TensorBranching.counting_mis1","text":"counting_mis1(eg::EliminateGraph)\n\nCompute the size of the maximum independent set (MIS) in the given EliminateGraph and the number of branches by mis1.\n\nArguments\n\neg::EliminateGraph: The graph to compute the MIS for.\n\nReturns\n\nCountingMIS: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.counting_mis2-Tuple{EliminateGraphs.EliminateGraph}","page":"API","title":"TensorBranching.counting_mis2","text":"counting_mis2(eg::EliminateGraph)\n\nCompute the size of the maximum independent set (MIS) in the given EliminateGraph and the number of branches by mis2.\n\nArguments\n\neg::EliminateGraph: The graph to compute the MIS for.\n\nReturns\n\nCountingMIS: The size of the maximum independent set.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.cover-Union{Tuple{TF}, Tuple{T}, Tuple{N}, Tuple{AbstractArray{SubCover{N, T}, 1}, Int64}} where {N, T, TF}","page":"API","title":"TensorBranching.cover","text":"cover(sub_covers::AbstractVector{SubCover{N, T}}; max_itr::Int = 2, min_complexity::TF = 1.0) where{N, T, TF}\n\nThe cover function performs a set covering algorithm on a collection of sub-covers.\n\nArguments\n\nsub_covers::AbstractVector{SubCover{N, T}}: A collection of sub-covers.\nmax_itr::Int = 2: The maximum number of iterations to perform.\nmin_complexity::TF = 1.0: The minimum complexity threshold.\n\nReturns\n\npicked: The selected sub-covers.\ncx: The complexity of the selected sub-covers.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_by-Tuple{Any, Any, Any}","page":"API","title":"TensorBranching.covered_by","text":"covered_by(a::BitStr, b::BitStr, mask::BitStr)\n\nCheck if a is covered by b with mask. The function returns true if and only if a and b are the same when masked by mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_by-Tuple{Any, Clause}","page":"API","title":"TensorBranching.covered_by","text":"covered_by(a::BitStr, clause::Clause)\n\nCheck if a is covered by the clause. The function returns true if and only if a and clause.val are the same when masked by clause.mask.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.covered_items-Tuple{Any, Clause}","page":"API","title":"TensorBranching.covered_items","text":"covered_items(bitstrings, clause::Clause)\n\nReturn the indices of the bit strings that are covered by the clause.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.missolve-Tuple{SimpleGraph, SolverConfig}","page":"API","title":"TensorBranching.missolve","text":"missolve(g::SimpleGraph, config::SolverConfig; show_count = false)\n\nSolve the maximum independent set problem for the given graph and configuration.\n\nArguments\n\ng::SimpleGraph: the input graph\nconfig::SolverConfig: the solver configuration\n\nKeyword Arguments\n\nshow_count::Bool: whether to show the count of the MIS\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.optimal_branches-Tuple{SimpleGraph, AbstractVector, AbstractBranching}","page":"API","title":"TensorBranching.optimal_branches","text":"optimal_branches(g::SimpleGraph, vertices::AbstractVector, strategy::AbstractBranching; measurement::AbstractMeasure = NumOfVertices(), filter::AbstractTruthFilter = NoFilter())\n\nFind the optimal branches for the given graph and vertices.\n\nArguments\n\ng::SimpleGraph: the input graph\nvertices::AbstractVector: the vertices to be considered\nstrategy::AbstractBranching: the branching strategy, e.g., NaiveBranching(), SetCoverBranching()\n\nKeyword Arguments\n\nmeasurement::AbstractMeasure: the measurement for the branching strategy, e.g., NumOfVertices(), D3Measure()\nfilter::AbstractTruthFilter: the filter for the branching strategy, e.g., EnvFilter(), NoFilter()\ntable_solver: the solver configuration, e.g., TensorNetworkSolver()\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.subcovers-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{Array{BitStr{N, T}, 1}, 1}, Vector{Int64}, SimpleGraph, AbstractMeasure}} where {N, T}","page":"API","title":"TensorBranching.subcovers","text":"subcovers(bss::AbstractVector{Vector{BitStr{N, T}}}, vertices::Vector{Int}, g::SimpleGraph, use_rv::Bool) where {N, T}\n\nCompute the subcovers of a set of bit strings by iteratively gathering clauses.\n\nArguments\n\nbss::AbstractVector{Vector{BitStr{N, T}}}: A vector of vectors of bit strings.\nvertices::Vector{Int}: A vector of integers representing vertices.\ng::SimpleGraph: A simple graph.\nuse_rv::Bool: A boolean indicating whether to use the number of vertices removed.\n\nReturns\n\nallcovers::Vector{SubCover}: A vector of SubCover objects representing the subcovers.\n\n\n\n\n\n","category":"method"},{"location":"api/#TensorBranching.subcovers_naive-Union{Tuple{T}, Tuple{N}, Tuple{Union{AbstractArray{Array{BitStr{N, T}, 1}, 1}, Array{BitStr{N, T}, 1}}, Vector{Int64}, SimpleGraph, AbstractMeasure}} where {N, T}","page":"API","title":"TensorBranching.subcovers_naive","text":"subcovers_naive(bs, vertices, g, use_rv)\n\nCompute the subcovers for a given set of bit strings by search all possible clauses.\n\nArguments\n\nbs::Union{Vector{BitStr{N, T}}, AbstractVector{Vector{BitStr{N, T}}}}: The set of bit strings.\nvertices::Vector{Int}: The vertices.\ng::SimpleGraph: The graph.\nuse_rv::Bool: A flag indicating whether to use the number of vertices removed.\n\nReturns\n\nallcovers::Vector{SubCover{N, T}}: The computed subcovers.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorBranching","category":"page"},{"location":"#TensorBranching.jl","page":"Home","title":"TensorBranching.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensorBranching.jl.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Press ] to enter the package mode in Julia Repl, and type the following command to install the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/ArrogantGao/TensorBranching.jl","category":"page"},{"location":"#solve-the-maximum-independent-set-problem","page":"Home","title":"solve the maximum independent set problem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently we provide a simple interface to solve the maximum independent set problem. You can use the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> g = random_regular_graph(60, 3)\n{60, 90} undirected simple Int64 graph\n\njulia> missolve(g, strategy = SetCoverBranching(), kneighbor = 1, show_count = true, usr_rv = true)\n(26, 206)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where kneighbor for layer of neighbor considered, the first result is the size of the maximum independent set, and the second result is the number of branches visited.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The standard mis1 and mis2 strategies are also available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TensorBranching: counting_mis1, counting_mis2\n\njulia> using EliminateGraphs\n\njulia> counting_mis1(EliminateGraph(g))\nCountingMIS(26, 58148786)\n\njulia> counting_mis2(EliminateGraph(g))\nCountingMIS(26, 188)","category":"page"},{"location":"#Branching-Tree","page":"Home","title":"Branching Tree","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To check the branching process in detail, we store all the branching process as tree.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> g = random_regular_graph(20, 3)\n{20, 30} undirected simple Int64 graph\n\njulia> tree, mis = branching_tree(g, SetCoverBranching(), 1, use_rv = true)\n(G{20}\n├─ G{16}\n│  └─ G{14}\n│     ├─ G{11}\n│     │  └─ G{9}\n│     │     └─ G{7}\n│     │        ⋮\n│     │        \n│     └─ G{7}\n│        └─ G{5}\n│           └─ G{3}\n│              ⋮\n│              \n├─ G{12}\n│  └─ G{10}\n│     └─ G{8}\n│        ├─ G{5}\n│        │  └─ G{3}\n│        │     ⋮\n│        │     \n│        └─ G{3}\n│           └─ G{0}\n└─ G{16}\n   └─ G{14}\n      ├─ G{11}\n      │  └─ G{9}\n      │     └─ G{7}\n      │        ⋮\n      │        \n      └─ G{8}\n         └─ G{6}\n            └─ G{4}\n               ⋮\n               \n, 6)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the graph of current state, the vertices to be removed are stored:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> tree.graph\n{20, 30} undirected simple Int64 graph\n\njulia> tree.removed\n3-element Vector{Vector{Int64}}:\n [1, 5, 13, 20]\n [1, 5, 13, 10, 15, 20, 4, 16]\n [1, 5, 12, 16]","category":"page"},{"location":"","page":"Home","title":"Home","text":"the vertices to be removed correspond to the children of the current node.","category":"page"}]
}
